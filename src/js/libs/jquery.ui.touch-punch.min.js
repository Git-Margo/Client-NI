/*!
 * jQuery UI Touch Punch 0.2.3
 *
 * Copyright 2011ï¿½2014, Dave Furfero
 * Dual licensed under the MIT or GPL Version 2 licenses.
 *
 * Depends:
 *  jquery.ui.widget.js
 *  jquery.ui.mouse.js
 */
! function(a) {
    //function f(a, b, oldB) {
    function f(a, b) {
        if (!(a.originalEvent.touches.length > 1)) {
            if (a.cancelable) a.preventDefault();
            var c = a.originalEvent.changedTouches[0],
                d = document.createEvent("MouseEvents");
            d.initMouseEvent(b, !0, !0, window, 1, c.screenX, c.screenY, c.clientX, c.clientY, !1, !1, !1, !1, 0, null), a.target.dispatchEvent(d)
        }
    }


    if (a.support.touch = "ontouchend" in document, a.support.touch) {
        //if (a.support.touch = ('ontouchstart' in document || 'ontouchstart' in window || navigator.maxTouchPoints > 0 || navigator.msMaxTouchPoints > 0), a.support.touch) {
        var lastClientX, lastClientY;
        var e, b = a.ui.mouse.prototype,
            c = b._mouseInit,
            d = b._mouseDestroy;
        b._touchStart = function(a) {
            var b = this;
            //!e && b._mouseCapture(a.originalEvent.changedTouches[0]) && (e = !0, b._touchMoved = !1, f(a, "mouseover"), f(a, "mousemove"), f(a, "mousedown"))

            if (!e) {
                if (b._mouseCapture(a.originalEvent.changedTouches[0])) {

                    var zoom = typeof(Engine) != "undefined" && Engine.zoomFactor != null ? Engine.zoomFactor : 1;

                    //lastClientX = a.originalEvent.changedTouches[0].clientX * zoom;
                    //lastClientY = a.originalEvent.changedTouches[0].clientY  * zoom;

                    lastClientX = a.originalEvent.changedTouches[0].clientX;
                    lastClientY = a.originalEvent.changedTouches[0].clientY;

                    console.log('last', lastClientX, lastClientY)

                    e = !0;
                    b._touchMoved = !1
                    f(a, "mouseover");
                    f(a, "mousemove");
                    f(a, "mousedown");
                }
            }


        }, b._touchMove = function(a) {
            //e && (this._touchMoved = !0, f(a, "mousemove", this))

            var zoom = typeof(Engine) != "undefined" && Engine.zoomFactor != null ? Engine.zoomFactor : 1;

            //var newClientX = a.originalEvent.changedTouches[0].clientX * zoom;
            //var newClientY = a.originalEvent.changedTouches[0].clientY * zoom;

            var newClientX = a.originalEvent.changedTouches[0].clientX;
            var newClientY = a.originalEvent.changedTouches[0].clientY;

            //console.log('new', newClientX, newClientY)

            if (newClientX == lastClientX && newClientY == lastClientY) return;
            else {
                lastClientX = newClientX;
                lastClientY = newClientY;
            }

            if (e) this._touchMoved = !0, f(a, "mousemove")

        }, b._touchEnd = function(a) {
            //e && (f(a, "mouseup", this), f(a, "mouseout", this), this._touchMoved || f(a, "click", this), e = !1)
            //e && (f(a, "mouseup"), f(a, "mouseout"), this._touchMoved || f(a, "click"), e = !1)
            e && (f(a, "mouseup"), f(a, "mouseout"), e = !1)
        }, b._mouseInit = function() {
            var b = this;
            b.element.bind({
                touchstart: a.proxy(b, "_touchStart"),
                touchmove: a.proxy(b, "_touchMove"),
                touchend: a.proxy(b, "_touchEnd")
            }), c.call(b)
        }, b._mouseDestroy = function() {
            var b = this;
            b.element.unbind({
                touchstart: a.proxy(b, "_touchStart"),
                touchmove: a.proxy(b, "_touchMove"),
                touchend: a.proxy(b, "_touchEnd")
            }), d.call(b)
        }
    }
}(jQuery);